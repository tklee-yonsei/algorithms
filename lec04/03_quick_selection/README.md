# Quick Selection 알고리즘

Quick Selection은 Quick Sort의 분할 정복 아이디어를 응용하여 배열에서 k번째로 작은(또는 큰) 원소를 효율적으로 찾는 알고리즘입니다.

## 알고리즘 특징

### 시간복잡도

- **평균 시간복잡도**: O(n)
- **최악 시간복잡도**: O(n²)
- **공간복잡도**: O(log n) - 재귀 호출 스택

### Quick Sort와의 차이점

- **Quick Sort**: 전체 배열을 정렬 (양쪽 부분 모두 재귀 호출)
- **Quick Selection**: k번째 원소만 찾음 (필요한 한쪽 부분만 재귀 호출)

## 작동 원리

1. **분할(Partition)**: 피벗을 선택하여 배열을 두 부분으로 나눔
2. **위치 확인**: k번째 원소가 어느 부분에 있는지 확인
3. **선택적 재귀**: 필요한 부분에서만 재귀적으로 탐색
4. **종료**: 피벗이 정확히 k번째 위치에 있으면 반환

## 구현 파일들

- `quickSelection.c`: C언어 구현
- `quickSelection.py`: Python 구현
- `quickSelection.pseudo`: 의사코드

## 컴파일 및 실행

### C 버전

```bash
gcc -o quickSelection quickSelection.c
./quickSelection
```

### Python 버전

```bash
python3 quickSelection.py
```

## 예시 출력

```
원본 배열: [64, 34, 25, 12, 22, 11, 90, 3, 77, 45]

1번째로 작은 원소: 3
2번째로 작은 원소: 11
...
10번째로 작은 원소: 90

특별한 케이스들:
가장 작은 원소 (1번째): 3
중앙값 (median, 5번째): 25
가장 큰 원소 (10번째): 90
```

## 활용 예시

- **통계학**: 중앙값(median) 찾기
- **데이터 분석**: 백분위수(percentile) 계산
- **알고리즘**: Top-K 문제 해결
- **게임**: 랭킹 시스템에서 특정 순위 찾기

## 장점

1. **효율성**: 전체 정렬 없이 특정 순위 원소를 빠르게 찾음
2. **메모리 효율**: 원본 배열을 보존하면서 복사본에서 작업
3. **평균 선형 시간**: 대부분의 경우 O(n) 시간에 해결

## 주의사항

- 최악의 경우 O(n²) 시간이 소요될 수 있음
- 피벗 선택 전략에 따라 성능이 달라질 수 있음
- 중복된 원소가 많은 경우 성능 저하 가능
