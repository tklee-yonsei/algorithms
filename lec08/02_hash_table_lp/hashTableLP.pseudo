// hashTableLP.pseudo - Hash Table with Linear Probing

구조체 해시항목:
  키
  값
  사용여부 (true/false)
  삭제여부 (true/false) // lazy deletion을 위함
끝

구조체 해시테이블:
  테이블크기
  사용된항목수
  테이블 (해시항목 배열)
끝

함수 해시함수(키, 테이블크기):
  시작
    return 키 % 테이블크기
  끝

함수 해시테이블생성(크기):
  시작
    해시테이블 = 메모리할당(해시테이블크기)
    해시테이블.테이블크기 = 크기
    해시테이블.사용된항목수 = 0
    해시테이블.테이블 = 메모리할당(크기 * 해시항목크기)
    
    for i = 0 to 크기-1:
      해시테이블.테이블[i].사용여부 = false
      해시테이블.테이블[i].삭제여부 = false
    
    return 해시테이블
  끝

함수 삽입(해시테이블, 키, 값):
  시작
    // 로드 팩터가 너무 높으면 크기 조정
    if (해시테이블.사용된항목수 + 1) / 해시테이블.테이블크기 > 0.7:
      해시테이블 = 크기조정(해시테이블, 해시테이블.테이블크기 * 2)
    
    인덱스 = 해시함수(키, 해시테이블.테이블크기)
    원래인덱스 = 인덱스
    
    while true:
      if 해시테이블.테이블[인덱스].사용여부 == false 또는 해시테이블.테이블[인덱스].삭제여부 == true:
        // 빈 슬롯 또는 삭제된 슬롯 발견
        if 해시테이블.테이블[인덱스].사용여부 == false:
          해시테이블.사용된항목수 = 해시테이블.사용된항목수 + 1
        
        해시테이블.테이블[인덱스].키 = 키
        해시테이블.테이블[인덱스].값 = 값
        해시테이블.테이블[인덱스].사용여부 = true
        해시테이블.테이블[인덱스].삭제여부 = false
        return
      else if 해시테이블.테이블[인덱스].키 == 키:
        // 기존 키 업데이트
        해시테이블.테이블[인덱스].값 = 값
        return
      
      // 다음 슬롯으로 이동 (선형 탐사)
      인덱스 = (인덱스 + 1) % 해시테이블.테이블크기
      
      // 테이블이 가득 참 (이론적으로는 발생하지 않아야 함)
      if 인덱스 == 원래인덱스:
        출력("해시 테이블이 가득 참")
        return
  끝

함수 검색(해시테이블, 키):
  시작
    인덱스 = 해시함수(키, 해시테이블.테이블크기)
    원래인덱스 = 인덱스
    
    while 해시테이블.테이블[인덱스].사용여부 == true:
      if 해시테이블.테이블[인덱스].삭제여부 == false 그리고 해시테이블.테이블[인덱스].키 == 키:
        return 해시테이블.테이블[인덱스].값
      
      // 다음 슬롯으로 이동
      인덱스 = (인덱스 + 1) % 해시테이블.테이블크기
      
      // 한 바퀴 돌았으면 종료
      if 인덱스 == 원래인덱스:
        break
    
    return NULL // 키를 찾지 못함
  끝

함수 삭제(해시테이블, 키):
  시작
    인덱스 = 해시함수(키, 해시테이블.테이블크기)
    원래인덱스 = 인덱스
    
    while 해시테이블.테이블[인덱스].사용여부 == true:
      if 해시테이블.테이블[인덱스].삭제여부 == false 그리고 해시테이블.테이블[인덱스].키 == 키:
        // Lazy deletion: 삭제 표시만 함
        해시테이블.테이블[인덱스].삭제여부 = true
        해시테이블.사용된항목수 = 해시테이블.사용된항목수 - 1
        return true
      
      // 다음 슬롯으로 이동
      인덱스 = (인덱스 + 1) % 해시테이블.테이블크기
      
      // 한 바퀴 돌았으면 종료
      if 인덱스 == 원래인덱스:
        break
    
    return false // 키를 찾지 못함
  끝

함수 해시테이블출력(해시테이블):
  시작
    출력("해시 테이블 내용:")
    
    for i = 0 to 해시테이블.테이블크기-1:
      출력("슬롯 ", i, ": ")
      
      if 해시테이블.테이블[i].사용여부 == false:
        출력("(비어있음)")
      else if 해시테이블.테이블[i].삭제여부 == true:
        출력("(삭제됨)")
      else:
        출력("[", 해시테이블.테이블[i].키, ":", 해시테이블.테이블[i].값, "]")
      
      출력(줄바꿈)
  끝

함수 크기조정(해시테이블, 새크기):
  시작
    // 기존 데이터 백업
    기존테이블 = 해시테이블.테이블
    기존크기 = 해시테이블.테이블크기
    
    // 새 테이블 생성
    해시테이블.테이블크기 = 새크기
    해시테이블.사용된항목수 = 0
    해시테이블.테이블 = 메모리할당(새크기 * 해시항목크기)
    
    for i = 0 to 새크기-1:
      해시테이블.테이블[i].사용여부 = false
      해시테이블.테이블[i].삭제여부 = false
    
    // 기존 데이터를 새 테이블에 재삽입
    for i = 0 to 기존크기-1:
      if 기존테이블[i].사용여부 == true 그리고 기존테이블[i].삭제여부 == false:
        삽입(해시테이블, 기존테이블[i].키, 기존테이블[i].값)
    
    메모리해제(기존테이블)
    return 해시테이블
  끝

함수 로드팩터계산(해시테이블):
  시작
    return 해시테이블.사용된항목수 / 해시테이블.테이블크기
  끝

함수 해시테이블해제(해시테이블):
  시작
    메모리해제(해시테이블.테이블)
    메모리해제(해시테이블)
  끝
