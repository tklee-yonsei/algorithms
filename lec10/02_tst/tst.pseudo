// tst.pseudo

// TST (Ternary Search Tree) 노드 구조
구조 TSTNode:
  시작
    data              // 현재 노드의 문자
    hasValue          // 값 존재 여부
    value             // 저장할 값
    left              // 현재 문자보다 작은 문자 (포인터)
    middle            // 다음 문자로 이동 (포인터)
    right             // 현재 문자보다 큰 문자 (포인터)
  끝

함수 createTSTNode(character):
  시작
    // 새로운 TST 노드 생성 및 초기화
    node = 새로운 TSTNode 할당
    
    node.data = character
    node.hasValue = false
    node.value = 0
    node.left = NULL
    node.middle = NULL
    node.right = NULL
    
    return node
  끝

함수 insert(root, word, value, index):
  시작
    // TST에 단어와 값을 삽입 (재귀적 구현)
    // root: 현재 노드, word: 삽입할 단어, value: 저장할 값, index: 현재 문자 인덱스
    
    if index >= length(word):
      return root
    
    currentChar = word[index]
    
    // 루트가 NULL이면 새 노드 생성
    if root == NULL:
      root = createTSTNode(currentChar)
    
    // 현재 문자와 노드의 문자 비교
    if currentChar < root.data:
      root.left = insert(root.left, word, value, index)
    else if currentChar > root.data:
      root.right = insert(root.right, word, value, index)
    else:  // currentChar == root.data
      if index == length(word) - 1:
        // 단어의 마지막 문자에 도달
        root.hasValue = true
        root.value = value
      else:
        // 다음 문자로 이동
        root.middle = insert(root.middle, word, value, index + 1)
    
    return root
  끝

함수 insertWord(root, word, value):
  시작
    // TST에 단어와 값을 삽입하는 래퍼 함수
    return insert(root, word, value, 0)
  끝

함수 search(root, word, index):
  시작
    // TST에서 단어 검색 (재귀적 구현)
    // root: 현재 노드, word: 검색할 단어, index: 현재 문자 인덱스
    
    if root == NULL:
      return -1
    
    if index >= length(word):
      return -1
    
    currentChar = word[index]
    
    if currentChar < root.data:
      return search(root.left, word, index)
    else if currentChar > root.data:
      return search(root.right, word, index)
    else:  // currentChar == root.data
      if index == length(word) - 1:
        // 단어의 마지막 문자에 도달
        if root.hasValue == true:
          return root.value
        else:
          return -1
      else:
        // 다음 문자로 이동
        return search(root.middle, word, index + 1)
  끝

함수 searchWord(root, word):
  시작
    // TST에서 단어 검색하는 래퍼 함수
    return search(root, word, 0)
  끝

함수 startsWith(root, prefix, index):
  시작
    // 주어진 prefix로 시작하는 단어들이 있는지 확인 (재귀적 구현)
    
    if root == NULL:
      return false
    
    if index >= length(prefix):
      return true  // 모든 prefix 문자를 찾음
    
    currentChar = prefix[index]
    
    if currentChar < root.data:
      return startsWith(root.left, prefix, index)
    else if currentChar > root.data:
      return startsWith(root.right, prefix, index)
    else:  // currentChar == root.data
      if index == length(prefix) - 1:
        // prefix의 마지막 문자에 도달
        return true
      else:
        // 다음 문자로 이동
        return startsWith(root.middle, prefix, index + 1)
  끝

함수 startsWithPrefix(root, prefix):
  시작
    // 접두사 검색 래퍼 함수
    return startsWith(root, prefix, 0)
  끝

함수 getAllWordsHelper(node, prefix, results):
  시작
    // 주어진 노드 이하의 모든 단어를 수집하는 헬퍼 함수
    
    if node == NULL:
      return
    
    // 현재 노드에 값이 저장되어 있다면 결과에 추가
    if node.hasValue == true:
      add (prefix + node.data, node.value) to results
    
    // 왼쪽 서브트리 탐색 (현재 문자보다 작은 문자들)
    getAllWordsHelper(node.left, prefix, results)
    
    // 가운데 서브트리 탐색 (다음 문자들)
    getAllWordsHelper(node.middle, prefix + node.data, results)
    
    // 오른쪽 서브트리 탐색 (현재 문자보다 큰 문자들)
    getAllWordsHelper(node.right, prefix, results)
  끝

함수 getAllWords(root):
  시작
    // TST의 모든 단어와 값을 반환
    results = 빈 리스트
    
    if root != NULL:
      getAllWordsHelper(root, "", results)
    
    return results
  끝

함수 getNodeByPrefix(root, prefix, index):
  시작
    // prefix에 해당하는 노드를 찾아 반환 (재귀적 구현)
    
    if root == NULL:
      return NULL
    
    if index >= length(prefix):
      return root
    
    currentChar = prefix[index]
    
    if currentChar < root.data:
      return getNodeByPrefix(root.left, prefix, index)
    else if currentChar > root.data:
      return getNodeByPrefix(root.right, prefix, index)
    else:  // currentChar == root.data
      if index == length(prefix) - 1:
        // prefix의 마지막 문자에 도달
        return root
      else:
        // 다음 문자로 이동
        return getNodeByPrefix(root.middle, prefix, index + 1)
  끝

함수 getWordsWithPrefix(root, prefix):
  시작
    // 주어진 접두사로 시작하는 모든 단어와 값을 반환
    results = 빈 리스트
    
    if root == NULL or prefix == NULL:
      return results
    
    // prefix에 해당하는 노드를 찾음
    prefixNode = getNodeByPrefix(root, prefix, 0)
    
    if prefixNode == NULL:
      return results  // 접두사가 존재하지 않음
    
    // 해당 노드에 값이 있다면 추가 (prefix 자체가 완전한 단어인 경우)
    if prefixNode.hasValue == true:
      add (prefix, prefixNode.value) to results
    
    // 해당 노드의 middle 서브트리에서 모든 단어 수집
    getAllWordsHelper(prefixNode.middle, prefix, results)
    
    return results
  끝

함수 hasChildren(node):
  시작
    // 노드가 자식을 가지고 있는지 확인
    
    if node == NULL:
      return false
    
    return node.left != NULL or node.middle != NULL or node.right != NULL
  끝

함수 deleteHelper(root, word, index):
  시작
    // 삭제 헬퍼 함수 (재귀적 구현)
    // root: 현재 노드, word: 삭제할 단어, index: 현재 문자 인덱스
    // 반환: 삭제 후 현재 노드의 포인터 (NULL이면 노드 삭제됨)
    
    if root == NULL:
      return NULL
    
    if index >= length(word):
      return root
    
    currentChar = word[index]
    
    if currentChar < root.data:
      root.left = deleteHelper(root.left, word, index)
    else if currentChar > root.data:
      root.right = deleteHelper(root.right, word, index)
    else:  // currentChar == root.data
      if index == length(word) - 1:
        // 단어의 마지막 문자에 도달
        root.hasValue = false
        root.value = 0
        
        // 자식이 없다면 노드 삭제
        if hasChildren(root) == false:
          delete root
          return NULL
      else:
        // 다음 문자로 이동하여 삭제
        root.middle = deleteHelper(root.middle, word, index + 1)
        
        // 현재 노드에 값도 없고 자식도 없다면 삭제
        if root.hasValue == false and hasChildren(root) == false:
          delete root
          return NULL
    
    return root
  끝

함수 deleteWord(root, word):
  시작
    // TST에서 단어 삭제하는 래퍼 함수
    return deleteHelper(root, word, 0)
  끝

함수 destroyTST(root):
  시작
    // TST의 모든 노드를 메모리에서 해제
    
    if root == NULL:
      return
    
    // 후위 순회로 모든 자식 노드를 먼저 해제
    destroyTST(root.left)
    destroyTST(root.middle)
    destroyTST(root.right)
    
    // 현재 노드 해제
    delete root
  끝

함수 printTST(root, depth):
  시작
    // TST 구조를 시각적으로 출력 (디버깅용)
    
    if root == NULL:
      return
    
    // 오른쪽 서브트리 먼저 출력
    printTST(root.right, depth + 1)
    
    // 들여쓰기 및 현재 노드 출력
    for i = 0 to depth-1:
      print "    "
    
    print root.data
    if root.hasValue == true:
      print " [값:", root.value, "]"
    print newline
    
    // 왼쪽 서브트리 출력
    printTST(root.left, depth + 1)
  끝

함수 inOrderTraversal(root, word, results):
  시작
    // 중위 순회로 단어들을 사전순으로 수집
    
    if root == NULL:
      return
    
    // 왼쪽 서브트리 먼저
    inOrderTraversal(root.left, word, results)
    
    // 현재 노드 처리
    currentWord = word + root.data
    
    // 값이 있다면 결과에 추가
    if root.hasValue == true:
      add (currentWord, root.value) to results
    
    // 가운데 서브트리 (다음 문자들)
    inOrderTraversal(root.middle, currentWord, results)
    
    // 오른쪽 서브트리
    inOrderTraversal(root.right, word, results)
  끝

함수 getSortedWords(root):
  시작
    // 사전순으로 정렬된 모든 단어를 반환
    results = 빈 리스트
    
    if root != NULL:
      inOrderTraversal(root, "", results)
    
    return results
  끝

// 메인 알고리즘
함수 main():
  시작
    // TST 생성 및 테스트
    root = NULL
    
    print "=== TST (Ternary Search Tree) 테스트 ==="
    print ""
    
    // 테스트 데이터 삽입
    testWords = [("apple", 10), ("app", 5), ("application", 20), 
                 ("apply", 8), ("banana", 15), ("band", 12), ("bandana", 18),
                 ("cat", 25), ("car", 30), ("card", 35)]
    
    print "=== 단어 삽입 테스트 ==="
    for each (word, value) in testWords:
      root = insertWord(root, word, value)
      print "삽입:", word, "값:", value
    print ""
    
    // 검색 테스트
    print "=== 검색 테스트 ==="
    searchWords = ["apple", "app", "application", "appl", "banana", "dog", "car"]
    
    for each word in searchWords:
      result = searchWord(root, word)
      if result != -1:
        print "검색:", word, "-> 찾음, 값:", result
      else:
        print "검색:", word, "-> 없음"
    print ""
    
    // 접두사 검색 테스트
    print "=== 접두사 검색 테스트 ==="
    prefixes = ["app", "ban", "ca", "xyz"]
    
    for each prefix in prefixes:
      exists = startsWithPrefix(root, prefix)
      if exists == true:
        print "접두사:", prefix, "-> 존재함"
        words = getWordsWithPrefix(root, prefix)
        print "  관련 단어들:", words
      else:
        print "접두사:", prefix, "-> 존재하지 않음"
    print ""
    
    // TST 구조 출력
    print "=== TST 구조 출력 ==="
    printTST(root, 0)
    print ""
    
    // 사전순 정렬된 단어 출력
    print "=== 사전순 정렬된 모든 단어 ==="
    sortedWords = getSortedWords(root)
    for each (word, value) in sortedWords:
      print word, ":", value
    print ""
    
    // 삭제 테스트
    print "=== 삭제 테스트 ==="
    deleteWords = ["app", "banana", "card"]
    
    for each word in deleteWords:
      print "삭제 전 검색:", word, "->", searchWord(root, word)
      root = deleteWord(root, word)
      print "삭제 후 검색:", word, "->", searchWord(root, word)
      print ""
    
    // 삭제 후 남은 단어 출력
    print "=== 삭제 후 남은 모든 단어 ==="
    remainingWords = getAllWords(root)
    for each (word, value) in remainingWords:
      print word, ":", value
    print ""
    
    // 성능 비교를 위한 추가 테스트
    print "=== 대량 데이터 테스트 ==="
    
    // 많은 단어들을 삽입하여 성능 테스트 시뮬레이션
    largeTestWords = ["the", "and", "for", "are", "but", "not", "you", "all", 
                      "can", "had", "her", "was", "one", "our", "out", "day",
                      "get", "has", "him", "his", "how", "its", "may", "new",
                      "now", "old", "see", "two", "way", "who", "boy", "did"]
    
    testRoot = NULL
    for i = 0 to length(largeTestWords)-1:
      word = largeTestWords[i]
      testRoot = insertWord(testRoot, word, i + 100)
    
    print "대량 삽입 완료:", length(largeTestWords), "개 단어"
    
    // 접두사별 검색 성능 테스트
    testPrefixes = ["t", "a", "c", "w"]
    for each prefix in testPrefixes:
      prefixWords = getWordsWithPrefix(testRoot, prefix)
      print "접두사 '" + prefix + "'로 시작하는 단어 수:", length(prefixWords)
    
    // 메모리 해제
    destroyTST(root)
    destroyTST(testRoot)
    
    print "테스트 완료"
  끝