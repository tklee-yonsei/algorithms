// huffmanCode_pseudo
// 허프만 코드: 최적 이진 트리를 구성하여 데이터 압축을 수행하는 알고리즘

자료구조 노드:
  시작
    문자: character
    빈도: frequency  
    왼쪽자식: left
    오른쪽자식: right
  끝

함수 createNode(문자, 빈도):
  시작
    새노드 = 노드 할당
    새노드.문자 = 문자
    새노드.빈도 = 빈도
    새노드.왼쪽자식 = NULL
    새노드.오른쪽자식 = NULL
    새노드 반환
  끝

함수 buildHuffmanTree(문자배열, 빈도배열, 크기):
  시작
    // 1. 우선순위 큐(최소 힙) 생성
    우선순위큐 = 빈큐
    
    // 2. 각 문자에 대해 노드 생성하여 큐에 삽입
    i = 0부터 크기-1까지:
      노드 = createNode(문자배열[i], 빈도배열[i])
      우선순위큐에 노드 삽입
    
    // 3. 허프만 트리 구성
    우선순위큐의 크기가 1보다 클 동안:
      // 빈도가 가장 작은 두 노드 추출
      왼쪽노드 = 우선순위큐에서 최소값 추출
      오른쪽노드 = 우선순위큐에서 최소값 추출
      
      // 새 내부 노드 생성 (문자는 '$', 빈도는 두 노드의 합)
      합쳐진노드 = createNode('$', 왼쪽노드.빈도 + 오른쪽노드.빈도)
      합쳐진노드.왼쪽자식 = 왼쪽노드
      합쳐진노드.오른쪽자식 = 오른쪽노드
      
      // 합쳐진 노드를 다시 큐에 삽입
      우선순위큐에 합쳐진노드 삽입
    
    // 4. 루트 노드 반환 (마지막 남은 노드)
    루트 = 우선순위큐에서 추출
    루트 반환
  끝

함수 generateCodes(루트, 코드, 깊이, 코드테이블):
  시작
    만약 루트가 NULL이면:
      반환
    
    // 리프 노드인 경우 (문자 노드)
    만약 루트.왼쪽자식이 NULL이고 루트.오른쪽자식이 NULL이면:
      코드테이블[루트.문자] = 코드의 첫 깊이 비트들
      반환
    
    // 내부 노드인 경우 재귀 호출
    generateCodes(루트.왼쪽자식, 코드, 깊이+1, 코드테이블)
    코드의 깊이번째 비트를 1로 설정
    generateCodes(루트.오른쪽자식, 코드, 깊이+1, 코드테이블)
  끝

함수 huffmanCoding(문자배열, 빈도배열, 크기):
  시작
    // 1. 허프만 트리 구성
    루트 = buildHuffmanTree(문자배열, 빈도배열, 크기)
    
    // 2. 각 문자의 허프만 코드 생성
    코드테이블 = 빈테이블
    코드 = 0
    깊이 = 0
    generateCodes(루트, 코드, 깊이, 코드테이블)
    
    // 3. 결과 출력
    i = 0부터 크기-1까지:
      출력: "문자: " + 문자배열[i] + ", 빈도: " + 빈도배열[i] + ", 코드: " + 코드테이블[문자배열[i]]
  끝

주함수:
  시작
    문자배열 = ['A', 'B', 'C', 'D']
    빈도배열 = [60, 25, 10, 5]
    크기 = 4
    
    출력: "=== 허프만 코딩 결과 ==="
    huffmanCoding(문자배열, 빈도배열, 크기)
  끝
