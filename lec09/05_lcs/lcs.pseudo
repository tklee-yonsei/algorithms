// lcs.pseudo

함수 findLongestCommonSubstring(lcp, n):
  시작
    // LCP 배열에서 가장 긴 공통 부분 문자열 찾기
    maxLcp = 0
    maxIndex = -1
    
    for i = 1 to n-1:  // LCP[0]은 보통 0이므로 1부터 시작
      if lcp[i] > maxLcp:
        maxLcp = lcp[i]
        maxIndex = i
    
    return maxLcp, maxIndex
  끝

함수 findAllLongestCommonSubstrings(lcp, n):
  시작
    // 최대 길이와 같은 모든 LCP 위치 찾기
    maxLcp, _ = findLongestCommonSubstring(lcp, n)
    indices = []
    
    for i = 1 to n-1:
      if lcp[i] == maxLcp:
        indices.append(i)
    
    return maxLcp, indices
  끝

함수 findLongestCommonSubstringWithSuffixArray(text, suffixArray, lcp, n):
  시작
    // Suffix Array와 LCP 배열을 이용해 실제 문자열 반환
    maxLcp, maxIndex = findLongestCommonSubstring(lcp, n)
    
    if maxLcp == 0:
      return "", 0, -1, -1
    
    // 가장 긴 공통 부분 문자열이 나타나는 두 suffix의 시작 위치
    pos1 = suffixArray[maxIndex - 1]
    pos2 = suffixArray[maxIndex]
    
    // 실제 부분 문자열 추출
    commonSubstring = text[pos1...pos1 + maxLcp - 1]
    
    return commonSubstring, maxLcp, pos1, pos2
  끝

함수 findAllOccurrencesOfLCS(text, lcp, suffixArray, n):
  시작
    // 가장 긴 공통 부분 문자열의 모든 출현 위치 찾기
    maxLcp, indices = findAllLongestCommonSubstrings(lcp, n)
    
    if maxLcp == 0:
      return [], 0
    
    positions = []
    
    for each index in indices:
      pos1 = suffixArray[index - 1]
      pos2 = suffixArray[index]
      positions.append(pos1)
      positions.append(pos2)
    
    // 중복 제거 및 정렬
    uniquePositions = removeDuplicates(sort(positions))
    
    return uniquePositions, maxLcp
  끝

함수 findTopKLongestCommonSubstrings(lcp, suffixArray, text, n, k):
  시작
    // 상위 k개의 가장 긴 공통 부분 문자열 찾기
    lcpWithIndex = []
    
    for i = 1 to n-1:
      if lcp[i] > 0:
        lcpWithIndex.append((lcp[i], i))
    
    // LCP 길이로 내림차순 정렬
    sort(lcpWithIndex, reverse=True)
    
    results = []
    seen = set()
    
    for i = 0 to min(k-1, length(lcpWithIndex)-1):
      lcpLength, index = lcpWithIndex[i]
      pos1 = suffixArray[index - 1]
      pos2 = suffixArray[index]
      substring = text[pos1...pos1 + lcpLength - 1]
      
      if substring not in seen:
        seen.add(substring)
        results.append((substring, lcpLength, pos1, pos2))
    
    return results
  끝

함수 computeLCPStatistics(lcp, n):
  시작
    // LCP 배열의 통계 정보 계산
    validLcp = []
    
    for i = 1 to n-1:
      if lcp[i] > 0:
        validLcp.append(lcp[i])
    
    if length(validLcp) == 0:
      return 0, 0, 0, 0
    
    maxLcp = max(validLcp)
    minLcp = min(validLcp)
    avgLcp = sum(validLcp) / length(validLcp)
    totalCommonChars = sum(validLcp)
    
    return maxLcp, minLcp, avgLcp, totalCommonChars
  끝

함수 printLCSAnalysis(text, suffixArray, lcp, n):
  시작
    print "=== 가장 긴 공통 부분 문자열 분석 ==="
    print "문자열:", text
    print "Suffix Array:", suffixArray
    print "LCP Array:", lcp
    print ""
    
    // 기본 통계
    maxLcp, minLcp, avgLcp, totalCommon = computeLCPStatistics(lcp, n)
    print "LCP 통계:"
    print "  최대 LCP:", maxLcp
    print "  최소 LCP (0 제외):", minLcp
    print "  평균 LCP:", avgLcp
    print "  총 공통 문자 수:", totalCommon
    print ""
    
    // 가장 긴 공통 부분 문자열
    commonStr, length, pos1, pos2 = findLongestCommonSubstringWithSuffixArray(text, suffixArray, lcp, n)
    if length > 0:
      print "가장 긴 공통 부분 문자열:"
      print "  문자열:", commonStr
      print "  길이:", length
      print "  출현 위치:", pos1, "과", pos2
      print "  suffix[", pos1, "]:", text[pos1...]
      print "  suffix[", pos2, "]:", text[pos2...]
    else:
      print "공통 부분 문자열이 없습니다."
    print ""
    
    // 모든 출현 위치
    positions, maxLen = findAllOccurrencesOfLCS(text, lcp, suffixArray, n)
    if maxLen > 0:
      print "가장 긴 공통 부분 문자열의 모든 출현 위치:", positions
    print ""
    
    // 상위 3개 LCS
    topLCS = findTopKLongestCommonSubstrings(lcp, suffixArray, text, n, 3)
    print "상위 3개 가장 긴 공통 부분 문자열:"
    for i = 0 to length(topLCS)-1:
      str, len, p1, p2 = topLCS[i]
      print "  ", i+1, ":", str, "(길이", len, ", 위치", p1, "과", p2, ")"
  끝

// 메인 알고리즘
함수 main():
  시작
    // 테스트 케이스 1: 기본 예제
    print "=== LCS 테스트 1: banana ==="
    text1 = "banana"
    suffixArray1 = [5, 3, 1, 0, 4, 2]  // 미리 계산된 값
    lcp1 = [0, 1, 3, 0, 0, 2]  // 미리 계산된 값
    n1 = length(text1)
    
    printLCSAnalysis(text1, suffixArray1, lcp1, n1)
    
    // 테스트 케이스 2: 복잡한 예제
    print "=== LCS 테스트 2: mississippi ==="
    text2 = "mississippi"
    suffixArray2 = [10, 7, 4, 1, 0, 9, 8, 6, 3, 5, 2]  // 미리 계산된 값
    lcp2 = [0, 1, 1, 4, 0, 0, 1, 0, 2, 1, 3]  // 미리 계산된 값
    n2 = length(text2)
    
    printLCSAnalysis(text2, suffixArray2, lcp2, n2)
    
    // 테스트 케이스 3: 반복 패턴
    print "=== LCS 테스트 3: abcabcabc ==="
    text3 = "abcabcabc"
    // 실제로는 suffix array 알고리즘으로 계산해야 함
    suffixArray3 = [0, 3, 6, 1, 4, 7, 2, 5, 8]  // 가정된 값
    lcp3 = [0, 6, 3, 0, 3, 0, 0, 0, 0]  // 가정된 값
    n3 = length(text3)
    
    printLCSAnalysis(text3, suffixArray3, lcp3, n3)
    
    // 테스트 케이스 4: 단순 통계 테스트
    print "=== 단순 LCP 배열 테스트 ==="
    lcpSimple = [0, 2, 1, 4, 0, 3, 1]
    maxLcp, maxIndex = findLongestCommonSubstring(lcpSimple, 7)
    print "LCP 배열:", lcpSimple
    print "최대 LCP:", maxLcp, "위치:", maxIndex
    
    allMax, indices = findAllLongestCommonSubstrings(lcpSimple, 7)
    print "최대값과 같은 모든 위치:", indices
  끝
