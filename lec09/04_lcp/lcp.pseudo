// lcp.pseudo

함수 computeLCP(s, i, j, n):
  시작
    // LCP (Longest Common Prefix) 계산
    // s: 문자열, i, j: 비교할 두 위치, n: 문자열 길이
    
    lcp = 0
    
    // 두 위치에서 시작하는 문자들을 하나씩 비교
    while i + lcp < n and j + lcp < n and s[i + lcp] == s[j + lcp]:
      lcp = lcp + 1
    
    return lcp
  끝

함수 computeAllLCP(s, positions, n, posCount):
  시작
    // 주어진 모든 위치 쌍에 대해 LCP 계산
    results[0...posCount-1][0...posCount-1]
    
    for i = 0 to posCount-1:
      for j = 0 to posCount-1:
        if i != j:
          results[i][j] = computeLCP(s, positions[i], positions[j], n)
        else:
          results[i][j] = n - positions[i]  // 자기 자신과의 LCP는 남은 문자열 길이
    
    return results
  끝

함수 findMaxLCP(s, positions, n, posCount):
  시작
    // 모든 위치 쌍 중 최대 LCP 찾기
    maxLcp = 0
    bestI = -1
    bestJ = -1
    
    for i = 0 to posCount-1:
      for j = i+1 to posCount-1:
        currentLcp = computeLCP(s, positions[i], positions[j], n)
        if currentLcp > maxLcp:
          maxLcp = currentLcp
          bestI = positions[i]
          bestJ = positions[j]
    
    return maxLcp, bestI, bestJ
  끝

함수 buildLCPKasai(text, sa, n):
  시작
    // Suffix Array로부터 LCP 배열 구축 (Kasai 알고리즘)
    lcp[0...n-1]
    rank[0...n-1]
    
    // Step 1: SA의 역함수 구성
    for i = 0 to n-1:
      rank[sa[i]] = i
    
    h = 0  // 현재 LCP 길이
    lcp[0] = 0
    
    // Step 2: 텍스트 순서로 각 suffix 처리
    for i = 0 to n-1:
      if rank[i] > 0:
        j = sa[rank[i] - 1]  // 이전 suffix의 시작 위치
        
        // h값부터 시작하여 공통 접두사 길이 계산
        while i + h < n and j + h < n and text[i + h] == text[j + h]:
          h = h + 1
        
        lcp[rank[i]] = h
        
        // 다음 iteration을 위해 h를 1 감소
        if h > 0:
          h = h - 1
    
    return lcp
  끝

함수 printLCPComparison(s, i, j, lcp):
  시작
    print "위치", i, ":", s[i...n-1]
    print "위치", j, ":", s[j...n-1]
    print "LCP 길이:", lcp
    if lcp > 0:
      print "공통 접두사:", s[i...i+lcp-1]
    else:
      print "공통 접두사: 없음"
  끝

// 메인 알고리즘
함수 main():
  시작
    // 테스트 문자열들
    text1 = "banana"
    text2 = "abcabcab"
    text3 = "mississippi"
    
    print "=== LCP 계산 테스트 1 ==="
    print "문자열:", text1
    n1 = length(text1)
    
    // 몇 가지 위치 쌍에 대해 LCP 계산
    pairs = [(0,1), (0,3), (1,3), (2,4)]
    for each (i, j) in pairs:
      lcp = computeLCP(text1, i, j, n1)
      printLCPComparison(text1, i, j, lcp)
      print ""
    
    print "=== LCP 계산 테스트 2 ==="
    print "문자열:", text2
    n2 = length(text2)
    
    // 반복 패턴이 있는 문자열에서 LCP 찾기
    maxLcp, pos1, pos2 = findMaxLCP(text2, [0,1,2,3,4,5], n2, 6)
    print "최대 LCP:", maxLcp, "위치:", pos1, "과", pos2
    
    print "=== Suffix Array와 LCP 배열 테스트 ==="
    print "문자열:", text3
    n3 = length(text3)
    
    // 가상의 suffix array (실제로는 다른 알고리즘으로 구축)
    suffixArray3 = [10, 7, 4, 1, 0, 9, 8, 6, 3, 5, 2]
    lcpArray3 = buildLCPKasai(text3, suffixArray3, n3)
    
    print "Suffix Array:", suffixArray3
    print "LCP Array:", lcpArray3
    
    // LCP 배열의 각 값이 의미하는 바 설명
    for i = 1 to n3-1:
      pos1 = suffixArray3[i-1]
      pos2 = suffixArray3[i]
      print "SA[", i-1, "] =", pos1, ", SA[", i, "] =", pos2
      print "LCP[", i, "] =", lcpArray3[i]
      if lcpArray3[i] > 0:
        print "공통 접두사:", text3[pos1...pos1+lcpArray3[i]-1]
      print ""
  끝
